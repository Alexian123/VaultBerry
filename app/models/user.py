from sqlalchemy import Integer, String, Boolean, BigInteger, Enum
from sqlalchemy.orm import Mapped, mapped_column, MappedColumn, relationship
from flask_login import UserMixin
from base64 import b64encode, b64decode, b32encode
from typing import TYPE_CHECKING, List
import pyotp
import qrcode
import io
from app import db, scram
from app.util import security, get_now_timestamp

if TYPE_CHECKING:
    from .secret import Secret
    from .one_time_password import OneTimePassword
    from .vault_entry import VaultEntry

class User(db.Model, UserMixin):
    __tablename__ = "users"

    id: MappedColumn[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    role: MappedColumn[str] = mapped_column(Enum("USER", "ADMIN", name="user_role", native_enum=True), server_default="USER")
    
    # Account Info
    email: MappedColumn[str] = mapped_column(String(255), unique=True)
    first_name: MappedColumn[str] = mapped_column(String(255), nullable=True)
    last_name: MappedColumn[str] = mapped_column(String(255), nullable=True)
    created_at: MappedColumn[int] = mapped_column(BigInteger)
    
    # 2FA
    mfa_enabled: MappedColumn[bool] = mapped_column(Boolean, default=False)
    
    # Credentials
    secrets: Mapped[List["Secret"]] = relationship("Secret", back_populates="user", cascade="all, delete")
    otps: Mapped[List["OneTimePassword"]] = relationship("OneTimePassword", back_populates="user", cascade="all, delete")
    
    # Vault
    entries: Mapped[List["VaultEntry"]] = relationship("VaultEntry", back_populates="user", cascade="all, delete")
    
    
    def is_admin(self):
        """
        Returns True if the user is an admin, False otherwise.
        """
        return self.role == "ADMIN"

    def account_dict(self):
        return {
            "email": self.email,
            "first_name": self.first_name,
            "last_name": self.last_name,
            "created_at": self.created_at
        }
        
    def set_scram_auth_info(self, salt: bytes, stored_key: bytes, server_key: bytes, iteration_count: int):
        """Stores the SCRAM auth information

        Args:
            salt (bytes): The SCRAM salt, generated by the server
            stored_key (bytes): The stored SCRAM key
            server_ley (bytes): The SCRAM server key
            iteration_count (int): The iteration count for the SCRAM hash function
        """
        # Find the secrets
        stored_key_secret: Secret = next((s for s in self.secrets if s.type == "SCRAM_STORED"), None)
        server_key_secret: Secret = next((s for s in self.secrets if s.type == "SCRAM_SERVER"), None)
        if stored_key_secret is None or server_key_secret is None:
            raise Exception("Missing scram secret")
        
        # Store the info
        stored_key_secret.salt = salt
        stored_key_secret.iteration_count = iteration_count
        stored_key_secret.set_secret(stored_key)
        server_key_secret.salt = salt
        server_key_secret.iteration_count = iteration_count
        server_key_secret.set_secret(server_key)
        
        
    def set_recovery_password(self, password: str):
        """
        Hashes, encrypts and stores the recovery password.
        """
        hashed_password = security.hasher.hash(password)
        recovery_secret: Secret = next((s for s in self.secrets if s.type == "RECOVERY"), None)
        if recovery_secret is None:
            raise Exception("Missing recovery secret")
        recovery_secret.set_secret(hashed_password.encode())
        
    def check_recovery_password(self, password: str):
        """
        Checks the recovery password.
        """
        recovery_secret: Secret = next((s for s in self.secrets if s.type == "RECOVERY"), None)
        if recovery_secret is None:
            raise Exception("Missing recovery secret")
        hashed_password = recovery_secret.get_secret().decode()
        return security.hasher.check(hashed_password, password)
        
        
    def generate_totp_secret(self) -> tuple[str, str]:
        """Generates, derives, encrypts, and stores a new TOTP secret.

        Returns:
            (str, str): The Provisioning URI as a string and as a QR code
        """
        
        # Generate TOTP secret
        secret = pyotp.random_base32()
        
        # Derive the secret
        salt = security.generator.random_bytes(16)
        derived_key = security.kdf.derive_key(secret.encode(), salt)
        
        # Store the secret
        totp_secret: Secret = next((s for s in self.secrets if s.type == "TOTP"), None)
        if totp_secret is None:
            raise Exception("Missing TOTP secret")
        totp_secret.salt = salt
        totp_secret.set_secret(derived_key)
        
        # Generate the provisioning URI
        encoded_derived_key = b32encode(derived_key).decode("utf-8").rstrip("=")
        provisioning_uri = pyotp.totp.TOTP(encoded_derived_key).provisioning_uri(
            name=self.email, issuer_name="VaultBerry"
        )

        # Generate the QR code
        qr = qrcode.make(provisioning_uri)
        buffered = io.BytesIO()
        qr.save(buffered)
        img_str = b64encode(buffered.getvalue()).decode()
        
        # Update the flag
        self.mfa_enabled = True
        
        return provisioning_uri, img_str
    
    def verify_totp_code(self, code: str) -> bool:
        """Verifies a totp code.
        
        Args:
            code (str): The TOTP code
            
        Returns:
            bool: True on success, False on failure
        """
        
        # Decrypt the secret
        totp_secret: Secret = next((s for s in self.secrets if s.type == "TOTP"), None)
        if totp_secret is None:
            raise Exception("Missing TOTP secret")
        derived_key = totp_secret.get_secret()
        encoded_derived_key = b32encode(derived_key).decode("utf-8").rstrip("=")
        
        # Verify the code
        totp = pyotp.TOTP(encoded_derived_key)
        return totp.verify(code)
    
    def set_vault_keychain(self, vault_key: str, recovery_key: str, salt: str):
        """Encrypts and stores the vault key, recovery key and salt.

        Args:
            vault_key (str): The base64 encoded vault key
            recovery_key (str): The base64 encoded recovery key
            salt (str): The base64 encoded salt, generated by the client
        """
        salt_bytes = b64decode(salt)
        vault_key_bytes = b64decode(vault_key)
        recovery_key_bytes = b64decode(recovery_key)
        
        vault_key_secret: Secret = next((s for s in self.secrets if s.type == "VAULT_KEY"), None)
        if vault_key_secret is None:
            raise Exception("Missing Vault Key secret")
        vault_key_secret.salt = salt_bytes
        vault_key_secret.set_secret(vault_key_bytes)
        
        recovery_key_secret: Secret = next((s for s in self.secrets if s.type == "VAULT_RECOVERY"), None)
        if recovery_key_secret is None:
            raise Exception("Missing Vault Recovery secret")
        recovery_key_secret.salt = salt_bytes
        recovery_key_secret.set_secret(recovery_key_bytes)
    
    def get_vault_keychain_dict(self) -> dict[str, str]:
        """Decrypts and retrieves the vault key, recovery key and salt.
        """
        vault_key_secret: Secret = next((s for s in self.secrets if s.type == "VAULT_KEY"), None)
        if vault_key_secret is None:
            raise Exception("Missing Vault Key secret")
        vault_key_bytes = vault_key_secret.get_secret()
        encoded_vault_key = b64encode(vault_key_bytes).decode()
        
        recovery_key_secret: Secret = next((s for s in self.secrets if s.type == "VAULT_RECOVERY"), None)
        if recovery_key_secret is None:
            raise Exception("Missing Vault Recovery secret")
        recovery_key_bytes = recovery_key_secret.get_secret()
        encoded_recovery_key = b64encode(recovery_key_bytes).decode()
        
        encoded_salt = b64encode(vault_key_secret.salt).decode()
        
        return {
            "vault_key": encoded_vault_key,
            "recovery_key": encoded_recovery_key,
            "salt": encoded_salt
        }
    
    @classmethod
    def create_admin(cls, email: str, password: str):
        """Creates an admin user with the given email and password, if it doesn't exist.

        Args:
            email (str): The email for the admin user
            password (str): The password for the admin user

        Returns:
            User: The new or existing user on success, None on failure
        """
        try:
            # Check if an admin user with the given email already exists
            admin_user = db.session.query(cls).filter_by(role="ADMIN", email=email).first()
            if admin_user:
                return admin_user
            
            # Create a new admin user
            admin_user = cls(
                email=email,
                first_name="Admin",
                last_name="User",
                role="ADMIN",
                created_at=get_now_timestamp()
            )
            db.session.add(admin_user)
            db.session.flush()
            
            # Generate and store scram auth info for regular password
            from . import Secret
            salt, stored_key, server_key, iteration_count = scram.make_auth_info(password)
            stored_key_secret = Secret(user_id=admin_user.id, type="SCRAM_STORED", salt=salt, iteration_count=iteration_count)
            stored_key_secret.set_secret(stored_key)
            db.session.add(stored_key_secret)
            server_key_secret = Secret(user_id=admin_user.id, type="SCRAM_SERVER", salt=salt, iteration_count=iteration_count)
            server_key_secret.set_secret(server_key)
            db.session.add(server_key_secret)

            db.session.commit()  # Commit everything
            print(f"Admin with email '{email}' created successfully")
            return admin_user

        except Exception as e:
            db.session.rollback()
            print(f"Error creating admin user: {e}")
            return None
        
    @staticmethod
    def get_auth_information(email: str) -> (tuple[bytes, bytes, bytes, int] | None):
        try:
            user: User = User.query.filter_by(email=email).first()
            if not user:
                raise Exception("No user with this email exists")
            stored_key_secret: Secret = next((s for s in user.secrets if s.type == "SCRAM_STORED"), None)
            server_key_secret: Secret = next((s for s in user.secrets if s.type == "SCRAM_SERVER"), None)
            if not stored_key_secret or not server_key_secret:
                raise Exception("Missing scram secret")
            return stored_key_secret.salt, stored_key_secret.get_secret(), server_key_secret.get_secret(), stored_key_secret.iteration_count
        except Exception as e:
            return None